# For a process following a CEV dynamics, it is complicated to directly determine the distribution of its running maxibm/minibm. 
# The link between hitting times and deterministic differential equations allows us to obtain information about their CDF, through their
# Laplace Transform over the observed time. Those Laplace Transform are expressed through particular solutions of ODE, related to the infinitesimal
# generator of the process.

# We implement the theoretical results presented in: "Pricing and Hedging Path-Dependent Options Under the CEV Process" by D. Davydov and V. Linetsky.

import math
from numpy import  sign
from mpmath import power, sqrt, besseli, besselk, whitm, whitw, invertlaplace

# Auxiliary functions used to write the solutions of the related ODE
def h(b, a, beta, variable):
    return abs(b)*math.pow(variable,-2*beta)/(a*a*abs(beta))

def q(a, beta, variable):
    math.pow(variable, -beta)/(a*abs(beta))

def eps(b, beta):
    return sign(b*beta)

def m(beta):
    return 1/(4*abs(beta))

def v(beta):
    return 1/(2*abs(beta))

def k(b, beta, index):
    return eps(b, beta)*(0.5 + 1/(4*beta)) - index/(2*abs(b*beta))

def scale_m(a, b, beta, variable):
    #if beta == -0.5 :
    #    return math.pow(variable, -2*b/(a*a))
    #else:
    #    return math.exp((math.pow(variable, -(1+2*beta)) - 1)*2*b/(a*a*(1+2*beta)))

    return math.exp( -pow(variable, -2*beta)*b/(a*a*abs(beta) ))

def speed_m(a, b, beta, variable):
    return 2/(a*a*math.pow(variable, 2*(beta+1))*scale_m(a, b, beta, variable))

# As we have a second order ODE, the space of solutions is generated by two linearly independent solutions. We will work only with the first solution
# First solution - Phi
def psi(index, variable, b, a, beta):

    if b == 0:

        if beta < 0:
            return math.pow(variable, 0.5)*besseli(v(beta), sqrt(2*index*q(a,beta, variable)))
        else:
            return math.pow(variable, 0.5)*besselk(v(beta), sqrt(2*index*q(a,beta, variable)))
    else:

        if beta < 0:
            return math.pow(variable, beta + 0.5)*math.exp(0.5*eps(b,beta)*h(b, a, beta, variable))*whitm(k(b, beta, index), m(beta), h(b, a, beta, variable))
            
        else:
            return math.pow(variable, beta + 0.5)*math.exp(0.5*eps(b,beta)*h(b, a, beta, variable))*whitw(k(b, beta, index), m(beta), h(b, a, beta, variable))

# G(y, x_0, tau) is the probability that the running maximum of a CEV is greater than y. 
# Here we express the Laplace Transform of G, w.r.t tau.
def Laplace_Transform_joint_density(x, y, S_t, s, b, a, beta):
    
    num = psi(s, S_t, b, a, beta)*psi(s, y, b, a, beta)
    factor_den = psi(s, x, b, a, beta)
    den = factor_den*factor_den
    return num/den

# In order to have G(x, x_0, tau), we have to perform a Laplace Transform Inversion. 
# MapMath also provides Inverse Laplace Transform algorithms, that works faster and more precisely:
def joint_density(x, y, S_t, tau, b, a, beta):
    return scale_m(a, b, beta, x)*speed_m(a, b, beta, y)*float(invertlaplace(lambda s: Laplace_Transform_joint_density(x, y, S_t, s, b, a, beta), tau, method = 'dehoog', dps = 10))

